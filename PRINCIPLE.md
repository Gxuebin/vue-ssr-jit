# Vue SSR Just In Time Compilation

[中文](/PRINCIPLE.CN.md)

> When we render the Vue application on the server side, no matter how many times the server performs the rendering, most of the strings rendered by VNode are invariant, some of them are static html from the template and others are from nodes that are dynamically rendered by the template (although it is possible that the dynamic nodes may change on the client side, but they are invariant on the server side). Extracting both types of nodes and rendering only the truly dynamic nodes (those associated with serverPrefetch prefetch data) on the server side can significantly improve the rendering performance on the server side.

Extracting static HTML from a Vue template only requires parsing the template structure at compile time. To determine whether a dynamic node is static during the server-side rendering phase, you need to Diff the VNode at runtime. Transforming dynamic nodes into static HTML requires modifying the source code of the rendering function, and we named this technique for optimizing server-side rendering functions at runtime the SSR Just In Time Compilation (JIT)

## How to Diff VNode

The first issue is how to Diff, and to do this you need two VNodes, one that loads dynamic data via serverPrefetch / asyncData, which we call Dynamic VNode, and one that doesn't load any data, which we call Static VNode. we make the bold assumption that Static VNode renders consistent html for any user, and that Static VNode is a subset of Dynamic VNode, and the points of difference for different users are in the complement of Static VNode versus Dynamic VNode.

![补集](/material/complementary-set.png)

> The above assumptions are true for the vast majority of web applications, and some unexpected situations are discussed at the end of this article.

The core of Diff is to mark the Dynamic VNode from the Staitc VNode and to render only the marked Dynamic VNode next time, the technical schematic of the Diff algorithm is as follows.

![Diff](/material/diff.gif)

The pre-optimized Dynamic VNode rendering flowchart is as follows.

![before](/material/before.gif)

The optimized Dynamic VNode rendering flowchart is as follows.

![after](/material/after.gif)

## How to modify the source code of a rendering function

The difficulty in modifying the rendering function is how to establish the correspondence between the VNode and the source code, otherwise we have no way of knowing which code the node to be optimized is generated from, which seems very difficult. Fortunately Vue's template syntax provides nice constraints, and the built-in compilation engine ensures predictable code structure for rendering functions.

The structure of the rendering function generated by compiling the following template code is well documented.

```html
<template>
  <div>
    <static-view/>
    <dynamic-view/>
  </div>
</template>
```
```js
_c("div", [
  _c("static-view"),
  _c("dynamic-view")
], 1)
```

Execute `_c(xxx)` to generate a VNode node and parse `_c(xxx)` to generate an AST. Bind the AST to the VNode, modify the AST if the current VNode is a static node, and turn the AST into executable code after the VNode tree traversal. The executable code contains the optimizations we made for VNode. Detailed technical implementations can be found in the patch.js and patch-context.js files in the project.

The following flowchart demonstrates the process of modifying the source code of the rendering function.

![ast](/material/ast.png)

## These lead to optimization failures.

### cookie

Do not use cookies during the server-side rendering cycle unless you are sure that this data is not relevant to the user. Cookies can be used within the serverPrefetch / asyncData method, and can also be used after the server rendering cycle, e.g. `mounted`, `updated`, etc.

Not recommended usage.
```js
data() {
  let cookie = cookie;
  try {
    cookie = document.cookie;
  } catch(e) {
    cookie = global.xxx.cookie;
  }
  return {
    cookie
  };
},
```

Recommended Usage.
```js
mounted() {
  this.cookie = document.cookie;
},
```

### v-for

The `v-for` instruction recommends wrapping the DOM element separately and does not recommend using it side by side with other components. Since the for loop disrupts the AST's correspondence with VNode nodes, nodes containing v-for instructions will not be optimized unless the node level is all static.

Not recommended usage.
```html
<template>
  <div>
    <div v-for="item in items" :key="item.id">{{item.value}}</div>
    <static-view></static-view>
  </div>
</template>
```

Recommended Usage.
```html
<template>
  <div>
    <div>
      <div v-for="item in items" :key="item.id">{{item.value}}</div>
    </div>
    <static-view></static-view>
  </div>
</template>
```

### closure

In some scenarios, the rendering function references a closure variable, which in turn affects a dynamic node, and the rendering function generated backwards through ast cannot track the previous closure reference, and will throw an error when executing because it cannot find the variable. When this happens, the parsing engine will abandon the AST optimization of the current component and use the pre-optimized rendering function instead.

Not recommended usage.
```html
<template>
  <img :src="require(`@/assets/${img}`)" >
</template>
```

Recommended Usage.
```html
<template>
  <img :src="getImgUrl(img)" >
</template>
```